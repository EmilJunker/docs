\documentclass[paper=a4]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{url}

\title{Overview of IDS Internals}
\author{Rolf Krahl}

% Add a revision hint as a unnumbered footnote
\newcommand{\revhint}{%
  \begingroup%
  \let\thefootnote\relax%
  \footnote{Revision: \input{.revision}}%
  \addtocounter{footnote}{-1}%
  \endgroup%
}

\graphicspath{{../Abbildungen/}}

\begin{document}

\maketitle

\section{Introduction}

\revhint{}%
The ICAT Data Service (IDS) operates with delayed actions, internal
states, and multiple threads.  This makes it somewhat difficult to
understand from mere reading the sources what actions may be performed
under certain conditions.  A detailed knowlegde of the internal
processes of IDS may be needed to properly implement a storage plugin
in a non-trivial setup, in particular the context that each of the
plugin's methods may be called in.  This text shall provide a
reference to accommodate this need.  It is however restricted to the
case that the IDS is configured as a two level storage and the storage
unit is dataset.  The text is based on IDS server 1.3.0.

The workflow in the IDS can be sketched as follows: the IDS waits for
incoming service requests coming from the user.  In some cases, these
requests may be completed immediately.  In other cases, a deferred
operation that will be processed in the background later is queued.
Section \ref{sec:requests} lists the service request and what is done
in each case.  The various operations that are queued for any given
dataset are kept track of in a finite state machine.  This is detailed
in Section \ref{sec:fsm}.  When processing the queue, each of the
deferred operations is executed in a separate thread.  Section
\ref{sec:defops} describes what is being done for each of the
operations.


\section{Internal states}
\label{sec:states}

The processing of a data object is influenced by its internal state
and what operations have been queued for them.  We say that an
operation is \emph{in process} on a dataset if this operation is
either in the queue or if it is currently being executed for that
dataset.

The status of a dataset may either be \texttt{ONLINE},
\texttt{ARCHIVED}, or \texttt{RESTORING}.  It is \texttt{RESTORING} if
a \texttt{RESTORE} operation on that dataset is in process.  If this
is not the case, the status is \texttt{ARCHIVED} if any other
operation then \texttt{WRITE} is in process or if the dataset is not
empty (e.g. related datafiles exist), but the dataset directory does
not exist in the main storage.  In all other cases, the status is
\texttt{ONLINE}.


\section{Service requests}
\label{sec:requests}

In this section, we consider each IDS request and describe in detail
what is done in each case.  We consider only requests that interact in
any way with the storage plugin.  The requests \texttt{getApiVersion},
\texttt{getServiceStatus}, \texttt{getSize} \texttt{isReadOnly},
\texttt{isTwoLevel}, and \texttt{ping} are thus skipped.

Several service calls that deal with a selection of data objects in
the storage expect lists of datafile, dataset, and investigation ids
as parameter.  Most internal processing is done at dataset level and
it only matters which datasets are concerned.  In these cases, we use
the term \emph{selected datasets} regardless whether the objects have
actually been selected by datafile, dataset, or investigation id.  In
a similar manner, we use the term \emph{selected datafiles}.

\subsection{\texttt{archive}}

Queue an \texttt{ARCHIVE} deferred operation for each of the selected
datasets.

\subsection{\texttt{delete}}

If any of the selected datasets is not \texttt{ONLINE}
(Sec.\ \ref{sec:states}), queue a \texttt{RESTORE} deferred operation
for them and throw a \texttt{DataNotOnlineException}.

Otherwise delete the selected datafiles from ICAT and from the main
storage.  Finally queue a \texttt{WRITE} deferred operation for each
of the selected datasets.

\subsection{\texttt{getData}}

If any of the selected datasets is not \texttt{ONLINE}
(Sec.\ \ref{sec:states}), queue a \texttt{RESTORE} deferred operation
for them and throw a \texttt{DataNotOnlineException}.

Otherwise get the selected datafiles from the main storage and stream
their content to the client.

\subsection{\texttt{getLink}}

If the dataset related to the selected datafile is not \texttt{ONLINE}
(Sec.\ \ref{sec:states}), queue a \texttt{RESTORE} deferred operation
for it and throw a \texttt{DataNotOnlineException}.

Otherwise get the path of the file from main storage, set an ACL to
grant read permission to the user on the file, and create a link to
the file.

\subsection{\texttt{getStatus}}

Return \texttt{ONLINE} if all selected datasets are \texttt{ONLINE}
(Sec.\ \ref{sec:states}), otherwise return either \texttt{ARCHIVED} or
\texttt{RESTORING}.

\subsection{\texttt{isPrepared}}

If any of the selected datasets (as stored in the previously prepared
data selection) is not \texttt{ONLINE} (Sec.\ \ref{sec:states}), queue
a \texttt{RESTORE} deferred operation for them and return
\texttt{false}.

Otherwise return \texttt{true}.

\subsection{\texttt{prepareData}}

If any of the selected datasets is not \texttt{ONLINE}
(Sec.\ \ref{sec:states}), queue a \texttt{RESTORE} deferred operation
for them.  Store the data selection and other parameter of the request
and return the prepared id for later referral.

\subsection{\texttt{put}}

If the dataset referenced in the request is not \texttt{ONLINE}
(Sec.\ \ref{sec:states}), queue a \texttt{RESTORE} deferred operation
for it and throw a \texttt{DataNotOnlineException}.

Otherwise store the uploaded file in the main storage, create the
datafile object in ICAT, and queue a \texttt{WRITE} deferred operation
for the dataset.

\subsection{\texttt{restore}}

Queue an \texttt{RESTORE} deferred operation for each of the selected
datasets.


\section{Finite state machine}
\label{sec:fsm}

The finite state machine manages the queue of deferred operations for
each dataset.  The operation may be changed if another operation is
queued for the same dataset while the previous one is still waiting in
the queue, see Tab.\ \ref{tab:fsm} for the update matrix.
\begin{table}
  \centering
  \begin{tabular}{l|lll}
                                  & \texttt{ARCHIVE} & \texttt{RESTORE} & \texttt{WRITE} \\
    \hline
    none                          & \texttt{ARCHIVE} & \texttt{RESTORE} & \texttt{WRITE} \\
    \texttt{ARCHIVE}              & \texttt{ARCHIVE} & \texttt{RESTORE} & \texttt{WRITE\_THEN\_ARCHIVE} \\
    \texttt{RESTORE}              & \texttt{ARCHIVE} & \texttt{RESTORE} & \texttt{WRITE} \\
    \texttt{WRITE}                & \texttt{WRITE\_THEN\_ARCHIVE} & \texttt{WRITE} & \texttt{WRITE} \\
    \texttt{WRITE\_THEN\_ARCHIVE} & \texttt{WRITE\_THEN\_ARCHIVE} & \texttt{WRITE} & \texttt{WRITE\_THEN\_ARCHIVE} \\
  \end{tabular}
  \caption{Update matrix for queued operations.  Matrix entries are
    the result if a new operation (column) is queued while a previous
    one (row) is still wating in the queue.}
  \label{tab:fsm}
\end{table}

The queue is processed regularly by a timer task that starts a new
thread to execute each of the pending operations.  \texttt{WRITE}
operations are processed with a delay that is fixed when the oparation
is queued.  Any subsequent \texttt{WRITE} operation queued for the
same dataset pushes this delay further.


\section{Deferred operations}
\label{sec:defops}

When the queue of deferred operations is processed, starts a new
thread is started to execute each of them.  This section describes
what these threads do in each case.

\subsection{\texttt{ARCHIVE}}

Delete the dataset from the main storage.

\subsection{\texttt{RESTORE}}

Get the ZIP file of the dataset from the archive storage, extract the
datafiles from it, and stores the datafiles in the main storage.

\subsection{\texttt{WRITE}}

If the dataset directory does not exist in the main storage, delete
the ZIP file of the dataset from archive storage.

Otherwise create a new ZIP file, get all datafiles that belong to the
dataset (according to ICAT) from the main storage and add them to the
ZIP file.  Store this ZIP file in the archive storage.

\subsection{\texttt{WRITE\_THEN\_ARCHIVE}}

As the name suggests, same as \texttt{WRITE} and then
\texttt{ARCHIVE}:

If the dataset directory does not exist in the main storage, delete
the ZIP file of the dataset from archive storage.

Otherwise create a new ZIP file, get all datafiles that belong to the
dataset (according to ICAT) from the main storage and add them to the
ZIP file.  Store this ZIP file in the archive storage.  Delete the
dataset from the main storage.

\end{document}


